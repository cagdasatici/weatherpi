<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Kiosk</title>
    <style>
        /* Kiosk: ensure no system scrollbars or margins, inner areas can still scroll */
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden; /* Prevent browser chrome scrollbars */
        }

        /* Hide webkit scrollbars (Chromium) but keep scroll functionality */
        ::-webkit-scrollbar { width: 0 !important; height: 0 !important; }

        /* Remove focus outlines in kiosk mode */
        :focus { outline: none !important; }

        body {
            margin: 0;
            padding: 15px;
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            font-family: 'Arial', sans-serif;
            height: 100vh;
            box-sizing: border-box;
            display: grid;
            grid-template-rows: auto 1fr auto;
            grid-gap: 15px;
            cursor: none; /* Hide cursor by default for kiosk */
            user-select: none; /* Prevent text selection */
        }
        
        /* Show cursor temporarily when screen is touched/moved */
        body.show-cursor {
            cursor: default;
        }
        
        .main-weather {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 100%;
            overflow: hidden;
        }
        
        .weather-main {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .current-temp {
            font-size: 64px;
            font-weight: bold;
            margin: 0;
        }
        
        .weather-info {
            text-align: left;
        }
        
        .condition {
            font-size: 28px;
            margin: 8px 0;
        }
        
        .feels-like {
            font-size: 18px;
            opacity: 0.8;
        }

        .feels-icon {
            width: 20px;
            height: 20px;
            vertical-align: middle;
            margin-right: 8px;
        }
        
        .details {
            text-align: right;
            font-size: 36px;  /* Reduced from 48px - still 2.25x larger than original 16px */
        }
        
        .datetime {
            opacity: 1;       /* Full opacity for maximum readability */
            margin-bottom: 8px;
            font-weight: 500; /* Add some weight for better visibility */
        }
        
        .datetime-container {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
        }
        
        .calendar-icon {
            cursor: pointer;
            width: 64px;
            height: 64px;
            border-radius: 12px;
            background: rgba(255,255,255,0.12);
            border: 1px solid rgba(255,255,255,0.18);
            transition: transform 0.2s ease, background 0.2s ease;
            user-select: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(255,255,255,0.3);
            background-image: url('icons/calendar.svg');
            background-repeat: no-repeat;
            background-position: center;
            background-size: 60%;
            display: inline-block;
        }
        
        .calendar-icon:hover {
            background: rgba(255,255,255,0.3);
            transform: translateZ(0) scale(1.05); /* Slightly larger on hover */
        }
        
        .calendar-icon:active {
            background: rgba(255,255,255,0.4);
            transform: translateZ(0) scale(0.95);
        }
        
        .min-max {
            font-size: 22px;
            font-weight: bold;
        }
        
        .forecast {
            border-top: 2px solid rgba(255,255,255,0.3);
            padding-top: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 16px;
        }
        
        .forecast-day {
            text-align: center;
            flex: 1;
            padding: 10px;
        }
        
        .forecast-temp {
            font-weight: bold;
            font-size: 16px;
        }
        
        .error {
            color: #ff7675;
            text-align: center;
            font-size: 20px;
        }
        
        .loading {
            text-align: center;
            opacity: 0.7;
        }
        
        .weather-icon {
            width: 100px;
            height: 100px;
            object-fit: contain;
            margin: 0 10px 0 20px;
        }
        
        .main-weather {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 40px 0 20px 0; /* Add top margin for frame effect */
        }
        
        .weather-main {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .temp-section {
            text-align: left;
        }
        
        .temp-section .current-temp {
            margin: 0 0 5px 0;
        }
        
        .temp-section .feels-like {
            font-size: 22px;  /* Increased from 16px for better readability */
            color: #FFEAA7;   /* Warm, readable yellow-orange tone */
            font-weight: 500;
            margin-bottom: 3px;
            opacity: 1;       /* Full opacity for maximum readability */
        }
        
        .temp-section .min-max {
            font-size: 22px;  /* Increased from 18px for better readability */
            color: #E8F4FD;   /* Much more readable light blue-white */
            font-weight: 600;
        }
        
        .middle-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-gap: 20px;
            align-items: start;
            margin: 20px 0 40px 0; /* Add spacing for frame effect */
            max-width: 100%;
            overflow: hidden;
        }
        
        .forecast {
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-self: start;
            margin-top: -25px; /* Move forecast block up more aggressively */
            font-size: 14px;
        }
        
        .forecast-day {
            text-align: center;
            flex: 1;
            font-size: 16px; /* Bigger day labels (Sun, Mon, Tue) */
            font-weight: 500;
        }
        
        .forecast-temp-group {
            margin: 8px 0; /* More spacing */
        }
        
        .forecast-temp {
            font-size: 26px; /* Much bigger for better readability - increased from 20px */
            font-weight: bold;
            margin-bottom: 4px;
            color: #FFFFFF; /* Pure white for maximum contrast */
        }
        
        .charts {
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 15px;
            transition: border-color 0.3s ease;
        }
        
        .charts:hover {
            border-color: rgba(255,255,255,0.5);
        }
        
        .weather-icon {
            transition: transform 0.3s ease;
        }
        
        .weather-icon:hover {
            transform: scale(1.05);
        }
        
        #tempChart {
            max-height: 150px;
        }
        
        .cache-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            color: #FFE4B5;
            display: none;
            align-items: center;
            gap: 6px;
            opacity: 0.85;
            transition: opacity 0.3s ease;
        }
        
        .cache-indicator:hover {
            opacity: 1;
        }
        
        .cache-indicator .icon {
            font-size: 16px;
        }
        
        .cache-indicator .text {
            font-weight: 500;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }
    </style>
</head>
<body>
    <!-- Cache indicator -->
    <div id="cacheIndicator" class="cache-indicator">
        <span class="icon">📶</span>
        <span class="text" id="cacheIndicatorText">Using cached data</span>
    </div>
    
    <div class="main-weather">
        <div class="weather-main">
            <img id="weatherIcon" class="weather-icon" src="icons/sun.png" alt="Weather" style="display: none;">
            <div class="temp-section">
                <h1 class="current-temp" id="currentTemp">--°</h1>
                <div class="feels-like" id="feelsLike">🌡 Feels like --°</div>
                <div class="min-max" id="minMax">H: --° L: --°</div>
                <div class="rain-info" id="rainInfo" style="font-size: 18px; color: #81ECEC; font-weight: 500; margin-top: 3px;">☔ --% • --mm</div>
            </div>
        </div>
        <div class="details">
            <div class="datetime-container">
                <div class="datetime" id="datetime">Loading...</div>
                <div class="calendar-icon" id="calendarIcon"></div>
            </div>
        </div>
    </div>
    
    <div class="middle-section">
        <div class="forecast" id="forecast">
            <div class="loading">Loading forecast...</div>
        </div>
        <div class="charts">
            <canvas id="tempChart" width="400" height="150"></canvas>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <!-- Hammer.js for gesture detection -->
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
    <script>
        // ===== EMERGENCY DESKTOP ACCESS SYSTEM =====
        let rapidTapCount = 0;
        let rapidTapTimer = null;
        let desktopModeActive = false;
        let inactivityTimer = null;
        const RAPID_TAP_THRESHOLD = 7;  // 7 rapid taps to activate
        const RAPID_TAP_WINDOW = 3000;  // 3 seconds window
        const DESKTOP_TIMEOUT = 5000;   // 5 seconds before returning to kiosk
        
        function handleRapidTap(event) {
            event.preventDefault();
            rapidTapCount++;
            
            console.log(`🖱️ Rapid tap ${rapidTapCount}/${RAPID_TAP_THRESHOLD}`);
            
            // Clear existing timer
            if (rapidTapTimer) {
                clearTimeout(rapidTapTimer);
            }
            
            // Check if threshold reached
            if (rapidTapCount >= RAPID_TAP_THRESHOLD) {
                activateDesktopMode();
                return;
            }
            
            // Reset counter after time window
            rapidTapTimer = setTimeout(() => {
                console.log('🔄 Rapid tap window expired, resetting counter');
                rapidTapCount = 0;
            }, RAPID_TAP_WINDOW);
        }
        
        function activateDesktopMode() {
            if (desktopModeActive) return;
            
            console.log('🖥️ EMERGENCY: Activating desktop mode');
            desktopModeActive = true;
            rapidTapCount = 0;
            
            // Clear any existing timer
            if (rapidTapTimer) {
                clearTimeout(rapidTapTimer);
                rapidTapTimer = null;
            }
            
            // Show desktop access overlay
            showDesktopAccessOverlay();
            
            // Exit fullscreen if possible
            try {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                console.log('📱 Attempted to exit fullscreen');
            } catch (e) {
                console.log('⚠️ Cannot exit fullscreen:', e.message);
            }
            
            // Make window smaller to show desktop
            try {
                window.resizeTo(800, 600);
                window.moveTo(100, 100);
                console.log('📐 Resized window for desktop access');
            } catch (e) {
                console.log('⚠️ Cannot resize window:', e.message);
            }
            
            // Start inactivity timer
            startInactivityTimer();
        }
        
        function showDesktopAccessOverlay() {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'desktopAccessOverlay';
            overlay.innerHTML = `
                <div style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    font-family: Arial, sans-serif;
                ">
                    <div style="
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        padding: 40px;
                        border-radius: 20px;
                        text-align: center;
                        max-width: 500px;
                        border: 2px solid rgba(255,255,255,0.3);
                        backdrop-filter: blur(10px);
                    ">
                        <h2 style="margin: 0 0 20px 0; font-size: 2.5em;">🛠️ Emergency Desktop Access</h2>
                        <p style="font-size: 1.2em; margin-bottom: 30px; opacity: 0.9;">
                            Desktop access activated!<br>
                            Window resized to show desktop behind.
                        </p>
                        <div style="
                            background: rgba(255,255,255,0.1);
                            padding: 20px;
                            border-radius: 10px;
                            margin-bottom: 20px;
                        ">
                            <p style="margin: 0; font-size: 1.1em;">
                                ⏰ Auto-return to kiosk in: <span id="desktopCountdown">5</span>s
                            </p>
                        </div>
                        <button onclick="returnToKioskMode()" style="
                            background: rgba(244, 67, 54, 0.3);
                            border: 2px solid #F44336;
                            color: white;
                            padding: 15px 30px;
                            border-radius: 25px;
                            font-size: 1.1em;
                            cursor: pointer;
                            transition: all 0.3s;
                        " onmouseover="this.style.background='rgba(244, 67, 54, 0.5)'" 
                           onmouseout="this.style.background='rgba(244, 67, 54, 0.3)'">
                            🔙 Return to Kiosk Now
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Start countdown
            let countdown = 5;
            const countdownElement = document.getElementById('desktopCountdown');
            const countdownTimer = setInterval(() => {
                countdown--;
                if (countdownElement) {
                    countdownElement.textContent = countdown;
                }
                if (countdown <= 0) {
                    clearInterval(countdownTimer);
                }
            }, 1000);
        }
        
        function startInactivityTimer() {
            // Clear existing timer
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
            }
            
            inactivityTimer = setTimeout(() => {
                console.log('⏰ Inactivity timeout - returning to kiosk mode');
                returnToKioskMode();
            }, DESKTOP_TIMEOUT);
        }
        
        function returnToKioskMode() {
            if (!desktopModeActive) return;
            
            console.log('🔙 Returning to kiosk mode');
            desktopModeActive = false;
            
            // Clear timers
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
                inactivityTimer = null;
            }
            
            // Remove overlay
            const overlay = document.getElementById('desktopAccessOverlay');
            if (overlay) {
                overlay.remove();
            }
            
            // Return to fullscreen
            try {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
                console.log('📱 Returned to fullscreen');
            } catch (e) {
                console.log('⚠️ Cannot enter fullscreen:', e.message);
            }
            
            // Try to maximize window
            try {
                window.resizeTo(screen.width, screen.height);
                window.moveTo(0, 0);
            } catch (e) {
                console.log('⚠️ Cannot maximize window:', e.message);
            }
        }
        
        // Add event listeners for rapid tap detection
        document.addEventListener('touchstart', handleRapidTap, { passive: false });
        document.addEventListener('click', handleRapidTap);
        
        console.log('🛡️ Emergency desktop access system initialized');
        console.log(`   ${RAPID_TAP_THRESHOLD} rapid taps within ${RAPID_TAP_WINDOW/1000}s to activate`);
        console.log(`   Auto-return after ${DESKTOP_TIMEOUT/1000}s of inactivity`);
        
        // ===== END EMERGENCY DESKTOP ACCESS SYSTEM =====
        
    // OpenWeather API key removed from client for security.
    // The frontend now calls a local proxy at /api/* which keeps the
    // real API key on the server side (see server/app.py).
    const API_BASE = '/api';
    const LAT = 52.3008;
    const LON = 4.8639;
        
        // Helper function to calculate today's rain data from forecast
        function calculateTodayRain(forecastData) {
            const today = new Date().toDateString();
            let todayRainChance = 0;
            let todayRainAmount = 0;
            
            if (forecastData && forecastData.list) {
                const todayEntries = forecastData.list.filter(entry => {
                    const entryDate = new Date(entry.dt * 1000).toDateString();
                    return entryDate === today;
                });
                
                if (todayEntries.length > 0) {
                    todayRainChance = Math.max(...todayEntries.map(entry => (entry.pop || 0) * 100));
                    todayRainAmount = todayEntries.reduce((total, entry) => {
                        return total + (entry.rain ? (entry.rain['3h'] || 0) : 0);
                    }, 0);
                }
            }
            
            return { rainChance: Math.round(todayRainChance), rainAmount: todayRainAmount.toFixed(1) };
        }

        // Cache for last successful weather data
        let lastWeatherData = null;
        let lastForecastData = null;
        let lastUpdateTime = null;
        
        // Cache indicator functions
        function showCacheIndicator(ageMinutes = null) {
            const indicator = document.getElementById('cacheIndicator');
            const text = document.getElementById('cacheIndicatorText');
            
            if (indicator && text) {
                if (ageMinutes && ageMinutes > 0) {
                    if (ageMinutes < 60) {
                        text.textContent = `Data ${ageMinutes}m old`;
                    } else {
                        const hours = Math.floor(ageMinutes / 60);
                        text.textContent = `Data ${hours}h old`;
                    }
                } else {
                    text.textContent = 'Using cached data';
                }
                indicator.style.display = 'flex';
            }
        }
        
        function hideCacheIndicator() {
            const indicator = document.getElementById('cacheIndicator');
            if (indicator) {
                indicator.style.display = 'none';
            }
        }
        
        // Load cached data from localStorage on startup
        function loadCachedData() {
            try {
                const cached = localStorage.getItem('weatherCache');
                if (cached) {
                    const data = JSON.parse(cached);
                    lastWeatherData = data.weather;
                    lastForecastData = data.forecast;
                    lastUpdateTime = new Date(data.timestamp);
                    console.log('Loaded cached weather data from', lastUpdateTime.toLocaleString());
                }
            } catch (error) {
                console.warn('Failed to load cached data:', error);
            }
        }
        
        // Save successful data to localStorage
        function saveCachedData() {
            try {
                localStorage.setItem('weatherCache', JSON.stringify({
                    weather: lastWeatherData,
                    forecast: lastForecastData,
                    timestamp: lastUpdateTime
                }));
            } catch (error) {
                console.warn('Failed to save cached data:', error);
            }
        }
        
        function updateDateTime() {
            try {
                const now = new Date();
                console.log('Current time:', now);
                
                const dateOptions = { 
                    weekday: 'short', 
                    month: 'short', 
                    day: 'numeric'
                };
                const timeOptions = {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                };
                const dateStr = now.toLocaleDateString('en-US', dateOptions);
                const timeStr = now.toLocaleTimeString('en-US', timeOptions);
                
                console.log('Formatted date:', dateStr, 'time:', timeStr);
                
                const datetimeElement = document.getElementById('datetime');
                console.log('Datetime element:', datetimeElement);
                
                if (datetimeElement) {
                    datetimeElement.textContent = `${dateStr} ${timeStr}`;
                    console.log('DateTime updated successfully');
                } else {
                    console.error('Could not find datetime element');
                }
            } catch (error) {
                console.error('Error updating datetime:', error);
            }
        }
        
        function showCalendar() {
            console.log('Calendar icon clicked - navigating to calendar');
            window.location.href = 'calendar.html';
        }
        
        function initializeCalendarIcon() {
            const calendarIcon = document.getElementById('calendarIcon');
            if (calendarIcon) {
                // Remove any existing onclick
                calendarIcon.onclick = null;
                
                // Add smooth touch feedback
                calendarIcon.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    calendarIcon.style.transform = 'scale(0.95)';
                    calendarIcon.style.opacity = '0.7';
                }, { passive: false });
                
                calendarIcon.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    // Reset visual state
                    calendarIcon.style.transform = 'scale(1)';
                    calendarIcon.style.opacity = '1';
                    // Navigate immediately
                    window.location.href = 'calendar.html';
                }, { passive: false });
                
                // Fallback for mouse clicks
                calendarIcon.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    window.location.href = 'calendar.html';
                }, { passive: false });
                
                console.log('Calendar icon touch handlers initialized');
            } else {
                console.error('Calendar icon element not found');
            }
        }
        
        async function fetchWeather() {
            try {
                console.log('=== Starting fetchWeather ===');
                
                // Fetch current weather
                const currentURL = `${API_BASE}/weather?lat=${LAT}&lon=${LON}`;
                const currentResponse = await fetch(currentURL);
                
                if (!currentResponse.ok) {
                    throw new Error(`Current weather API returned ${currentResponse.status}`);
                }
                
                const currentData = await currentResponse.json();
                
                // Cache successful data
                lastWeatherData = currentData;
                lastUpdateTime = new Date();
                saveCachedData();
                
                // Update current weather
                document.getElementById('currentTemp').textContent = `${Math.round(currentData.main.temp)}°`;
                document.getElementById('feelsLike').textContent = `🌡 Feels like ${Math.round(currentData.main.feels_like)}°`;
                document.getElementById('minMax').textContent = `H: ${Math.round(currentData.main.temp_max)}° L: ${Math.round(currentData.main.temp_min)}°`;
                
                // Update weather icon
                const iconElement = document.getElementById('weatherIcon');
                const iconSrc = getWeatherIcon(currentData.weather[0].main.toLowerCase());
                iconElement.src = iconSrc;
                iconElement.style.display = 'block';
                
                // Fetch forecast
                const forecastURL = `${API_BASE}/forecast?lat=${LAT}&lon=${LON}`;
                const forecastResponse = await fetch(forecastURL);
                
                if (!forecastResponse.ok) {
                    throw new Error(`Forecast API returned ${forecastResponse.status}`);
                }
                
                const forecastData = await forecastResponse.json();
                
                // Get today's rain data using helper function
                const todayRain = calculateTodayRain(forecastData);
                
                // Update today's rain info
                document.getElementById('rainInfo').textContent = `☔ ${todayRain.rainChance}% • ${todayRain.rainAmount}mm`;
                
                // Cache successful forecast data
                lastForecastData = forecastData;
                saveCachedData();
                
                // Update forecast display and chart
                updateForecastDisplay(forecastData);
                createTempChart(forecastData);
                
                // Hide cache indicator since we have fresh data
                hideCacheIndicator();
                
                console.log('=== Weather update completed successfully ===');
                
            } catch (error) {
                console.error('Error fetching weather:', error);
                
                // Try to use cached data instead of showing error
                if (lastWeatherData && lastForecastData) {
                    console.log('Using cached weather data due to network error');
                    
                    // Show cached current weather
                    document.getElementById('currentTemp').textContent = `${Math.round(lastWeatherData.main.temp)}°`;
                    document.getElementById('feelsLike').textContent = `🌡 Feels like ${Math.round(lastWeatherData.main.feels_like)}°`;
                    document.getElementById('minMax').textContent = `H: ${Math.round(lastWeatherData.main.temp_max)}° L: ${Math.round(lastWeatherData.main.temp_min)}°`;
                    
                    // Update cached rain info
                    const cachedTodayRain = calculateTodayRain(lastForecastData);
                    document.getElementById('rainInfo').textContent = `☔ ${cachedTodayRain.rainChance}% • ${cachedTodayRain.rainAmount}mm`;
                    
                    // Update weather icon
                    const iconElement = document.getElementById('weatherIcon');
                    const iconSrc = getWeatherIcon(lastWeatherData.weather[0].main.toLowerCase());
                    iconElement.src = iconSrc;
                    iconElement.style.display = 'block';
                    
                    // Show cached forecast
                    updateForecastDisplay(lastForecastData);
                    createTempChart(lastForecastData);
                    
                    // Show cache indicator with age information
                    const ageMinutes = Math.floor((new Date() - lastUpdateTime) / 60000);
                    showCacheIndicator(ageMinutes);
                    
                    console.log(`Using ${ageMinutes} minute old cached data`);
                } else {
                    // Only show error if no cached data available
                    showError('Unable to fetch weather data');
                }
            }
        }
        
        function updateForecastDisplay(forecast) {
            try {
                console.log('=== Starting updateForecastDisplay ===');
                
                const forecastContainer = document.getElementById('forecast');
                if (!forecastContainer) {
                    console.error('Forecast container not found!');
                    return;
                }
                
                if (!forecast.list || !Array.isArray(forecast.list)) {
                    console.error('Invalid forecast data');
                    forecastContainer.innerHTML = '<div class="error">Invalid forecast data</div>';
                    return;
                }
                
                // Clear the container
                forecastContainer.innerHTML = '';
                
                // Get one forecast per day starting from tomorrow  
                const dailyForecasts = [];
                const today = new Date().toDateString();
                const seenDays = new Set([today]); // Exclude today
                
                // Find future forecast items for different days
                for (const item of forecast.list) {
                    const date = new Date(item.dt * 1000);
                    const dayKey = date.toDateString();
                    
                    if (!seenDays.has(dayKey) && dailyForecasts.length < 4) {
                        seenDays.add(dayKey);
                        dailyForecasts.push(item);
                    }
                }
                
                console.log('Found forecasts for', dailyForecasts.length, 'different days');
                
                // Create forecast cards
                dailyForecasts.forEach((item) => {
                    const date = new Date(item.dt * 1000);
                    const day = date.toLocaleDateString('en-US', { weekday: 'short' });
                    const temp = Math.round(item.main.temp);
                    const tempMax = Math.round(item.main.temp_max);
                    const tempMin = Math.round(item.main.temp_min);
                    const condition = item.weather[0].main;
                    const iconSrc = getWeatherIcon(condition.toLowerCase());
                    
                    // Get rain data
                    const rainChance = item.pop ? Math.round(item.pop * 100) : 0;
                    const rainAmount = item.rain ? (item.rain['3h'] || 0).toFixed(1) : '0.0';
                    
                    const dayDiv = document.createElement('div');
                    dayDiv.className = 'forecast-day';
                    dayDiv.innerHTML = `
                        <div>${day}</div>
                        <img src="${iconSrc}" alt="${condition}" style="width: 40px; height: 40px;">
                        <div class="forecast-temp-group">
                            <div class="forecast-temp">${temp}°</div>
                            <div style="font-size: 16px; color: #E8F4FD; font-weight: 600;">H:${tempMax}° L:${tempMin}°</div>
                        </div>
                        <div style="font-size: 16px; color: #81ECEC; font-weight: 600;">${rainChance}% • ${rainAmount}mm</div>
                    `;
                    forecastContainer.appendChild(dayDiv);
                });
                
                console.log('Forecast cards created successfully');
                
            } catch (error) {
                console.error('Error in updateForecastDisplay:', error);
                const forecastContainer = document.getElementById('forecast');
                if (forecastContainer) {
                    forecastContainer.innerHTML = `<div class="error">Display error: ${error.message}</div>`;
                }
            }
        }
        
        function updateWeatherDisplay(current, forecast) {
            try {
                console.log('Updating weather display with:', { current, forecast });
                
                // Current weather
                document.getElementById('currentTemp').textContent = `${Math.round(current.main.temp)}°`;
                document.getElementById('feelsLike').textContent = `🌡️ Feels like ${Math.round(current.main.feels_like)}°`;
                document.getElementById('minMax').textContent = `H: ${Math.round(current.main.temp_max)}° L: ${Math.round(current.main.temp_min)}°`;
                
                // Update weather icon
                const iconElement = document.getElementById('weatherIcon');
                const iconSrc = getWeatherIcon(current.weather[0].main.toLowerCase());
                iconElement.src = iconSrc;
                iconElement.style.display = 'block';
                
                console.log('Basic weather info updated');
                
                // Forecast - group by actual different days (excluding today)
                const forecastContainer = document.getElementById('forecast');
                forecastContainer.innerHTML = '';
                
                // Get one forecast per day starting from tomorrow
                const dailyForecasts = [];
                const today = new Date().toDateString();
                const seenDays = new Set([today]); // Exclude today
                
                for (const item of forecast.list) {
                    const date = new Date(item.dt * 1000);
                    const dayKey = date.toDateString();
                    
                    if (!seenDays.has(dayKey) && dailyForecasts.length < 4) {
                        seenDays.add(dayKey);
                        dailyForecasts.push(item);
                    }
                }
                
                dailyForecasts.forEach((item) => {
                    const date = new Date(item.dt * 1000);
                    const day = date.toLocaleDateString('en-US', { weekday: 'short' });
                    const temp = Math.round(item.main.temp);
                    const tempMax = Math.round(item.main.temp_max);
                    const tempMin = Math.round(item.main.temp_min);
                    const condition = item.weather[0].main;
                    const iconSrc = getWeatherIcon(condition.toLowerCase());
                    
                    // Get rain data
                    const rainChance = item.pop ? Math.round(item.pop * 100) : 0;
                    const rainAmount = item.rain ? (item.rain['3h'] || 0).toFixed(1) : '0.0';
                    
                    const dayDiv = document.createElement('div');
                    dayDiv.className = 'forecast-day';
                    dayDiv.innerHTML = `
                        <div>${day}</div>
                        <img src="${iconSrc}" alt="${condition}" style="width: 40px; height: 40px;">
                        <div class="forecast-temp-group">
                            <div class="forecast-temp">${temp}°</div>
                            <div style="font-size: 11px; color: #B0E0E6;">H:${tempMax}° L:${tempMin}°</div>
                        </div>
                        <div style="font-size: 12px; color: #B0E0E6; font-weight: bold;">${rainChance}% • ${rainAmount}mm</div>
                    `;
                    forecastContainer.appendChild(dayDiv);
                });
                
                // Create temperature chart
                createTempChart(forecast);
                
                console.log('Weather display update completed successfully');
                
            } catch (error) {
                console.error('Error updating weather display:', error);
                showError('Error displaying weather data');
            }
        }
        
        function getWeatherIcon(condition) {
            const iconMap = {
                'clear': 'icons/sun.png',
                'sunny': 'icons/sun.png',
                'clouds': 'icons/cloud.png',
                'cloudy': 'icons/cloud.png',
                'rain': 'icons/rain.png',
                'drizzle': 'icons/drizzle.png',
                'thunderstorm': 'icons/storm.png',
                'storm': 'icons/storm.png',
                'snow': 'icons/snow.png',
                'mist': 'icons/mist.png',
                'fog': 'icons/fog.png',
                'haze': 'icons/fog.png'
            };
            
            return iconMap[condition] || 'icons/sun.png';
        }
        
        function createTempChart(forecast) {
            const ctx = document.getElementById('tempChart').getContext('2d');
            
            // Clear any existing chart
            Chart.getChart(ctx)?.destroy();
            
            // Filter to only future data points (from now onwards)
            const now = new Date();
            const futureData = forecast.list.filter(item => {
                const itemDate = new Date(item.dt * 1000);
                return itemDate >= now;
            });
            
            // Get next 24 hours of future data (8 data points * 3 hours = 24 hours)
            const next24Hours = futureData.slice(0, 8);
            
            if (next24Hours.length === 0) {
                console.warn('No future weather data available for chart');
                return;
            }
            
            const labels = next24Hours.map(item => {
                const date = new Date(item.dt * 1000);
                return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
            });
            
            const temps = next24Hours.map(item => Math.round(item.main.temp));
            const rainData = next24Hours.map(item => item.rain ? item.rain['3h'] || 0 : 0);
            const hasRain = rainData.some(value => value > 0.5); // Only show rain bars if >0.5mm (meaningful precipitation)
            
            console.log('Rain data:', rainData, 'Max rain:', Math.max(...rainData), 'Has significant rain:', hasRain);
            
            // Calculate temperature range for proper scaling
            const minTemp = Math.min(...temps);
            const maxTemp = Math.max(...temps);
            const tempRange = maxTemp - minTemp;
            const padding = Math.max(2, tempRange * 0.1); // At least 2 degrees padding
            
            const yAxisMin = Math.floor(minTemp - padding);
            const yAxisMax = Math.ceil(maxTemp + padding);
            
            console.log(`Chart data: ${next24Hours.length} points, temp range: ${minTemp}° to ${maxTemp}°, y-axis: ${yAxisMin}° to ${yAxisMax}°`);
            
            // Create datasets array - only include rain if there's actual precipitation
            const datasets = [
                {
                    label: '🌡️',
                    data: temps,
                    borderColor: '#FFD700',
                    backgroundColor: 'rgba(255, 215, 0, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    yAxisID: 'y',
                    datalabels: {
                        display: true,
                        color: '#FFD700',
                        font: {
                            size: 16,
                            weight: 'bold'
                        },
                        formatter: function(value) {
                            return Math.round(value) + '°';
                        },
                        align: 'top',
                        anchor: 'center',
                        offset: 8
                    }
                }
            ];

            // Only add rain dataset if there's actual precipitation
            if (hasRain) {
                datasets.push({
                    label: '🌧️',
                    data: rainData,
                    borderColor: '#74b9ff',
                    backgroundColor: 'rgba(116, 185, 255, 0.3)',
                    borderWidth: 2,
                    type: 'bar',
                    yAxisID: 'y1',
                    datalabels: {
                        display: false
                    }
                });
            }

            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                plugins: [ChartDataLabels],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false  // Remove the legend boxes entirely
                        },
                        datalabels: {
                            display: false  // Default to false, individual datasets override
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: 'white', font: { size: 14 } },
                            grid: { color: 'rgba(255,255,255,0.2)' }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            min: yAxisMin,
                            max: yAxisMax,
                            ticks: { 
                                color: '#FFD700', 
                                font: { size: 14 },
                                stepSize: Math.max(1, Math.ceil(tempRange / 5))
                            },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        ...(hasRain && {
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                min: 0,
                                ticks: { color: '#74b9ff', font: { size: 14 } },
                                grid: { drawOnChartArea: false }
                            }
                        })
                    }
                }
            });
        }
        
        function showError(message) {
            console.error('showError called with:', message);
            // Only show error UI if no previous data exists
            if (!lastWeatherData) {
                document.getElementById('currentTemp').textContent = '--°';
                document.getElementById('feelsLike').textContent = '🌡️ Feels like --°';
                document.getElementById('minMax').textContent = 'H: --° L: --°';
                const forecastElement = document.getElementById('forecast');
                if (forecastElement) {
                    forecastElement.innerHTML = `<div class="error">Loading weather data...</div>`;
                }
            }
            // If we have cached data, keep showing it silently
        }
        
        // Initialize
        console.log('Starting weather app initialization...');
        
        // Load any cached data first
        loadCachedData();
        
        // Show cached data immediately if available
        if (lastWeatherData && lastForecastData) {
            console.log('Displaying cached data while fetching updates...');
            document.getElementById('currentTemp').textContent = `${Math.round(lastWeatherData.main.temp)}°`;
            document.getElementById('feelsLike').textContent = `🌡 Feels like ${Math.round(lastWeatherData.main.feels_like)}°`;
            document.getElementById('minMax').textContent = `H: ${Math.round(lastWeatherData.main.temp_max)}° L: ${Math.round(lastWeatherData.main.temp_min)}°`;
            
            // Update startup cached rain info
            const startupTodayRain = calculateTodayRain(lastForecastData);
            document.getElementById('rainInfo').textContent = `☔ ${startupTodayRain.rainChance}% • ${startupTodayRain.rainAmount}mm`;
            
            const iconElement = document.getElementById('weatherIcon');
            const iconSrc = getWeatherIcon(lastWeatherData.weather[0].main.toLowerCase());
            iconElement.src = iconSrc;
            iconElement.style.display = 'block';
            
            updateForecastDisplay(lastForecastData);
            createTempChart(lastForecastData);
            
            // Show cache indicator with age information
            const ageMinutes = Math.floor((new Date() - lastUpdateTime) / 60000);
            showCacheIndicator(ageMinutes);
        }
        
        // Cursor hiding for kiosk mode
        let cursorTimer;
        function showCursor() {
            document.body.classList.add('show-cursor');
            clearTimeout(cursorTimer);
            cursorTimer = setTimeout(() => {
                document.body.classList.remove('show-cursor');
            }, 3000); // Hide cursor after 3 seconds
        }
        
        // RELIABLE TOUCH-ONLY NAVIGATION SYSTEM
        // No external libraries needed - works offline
        function initializeSwipeGestures() {
            console.log('🚀 Initializing RELIABLE touch navigation...');
            
            let startX = 0;
            let startY = 0;
            let currentX = 0;
            let currentY = 0;
            let isSwipeGesture = false;
            
            // Touch start
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length !== 1) return; // Only single touch
                
                const touch = e.touches[0];
                startX = touch.clientX;
                startY = touch.clientY;
                isSwipeGesture = true;
                
                console.log(`👆 Touch start at: ${startX}, ${startY}`);
            }, { passive: false });
            
            // Touch move - track movement
            document.addEventListener('touchmove', (e) => {
                if (!isSwipeGesture || e.touches.length !== 1) return;
                
                const touch = e.touches[0];
                currentX = touch.clientX;
                currentY = touch.clientY;
                
                // Prevent scrolling during swipe
                e.preventDefault();
            }, { passive: false });
            
            // Touch end - detect swipe
            document.addEventListener('touchend', (e) => {
                if (!isSwipeGesture) return;
                
                const deltaX = currentX - startX;
                const deltaY = currentY - startY;
                const absDeltaX = Math.abs(deltaX);
                const absDeltaY = Math.abs(deltaY);
                
                console.log(`👋 Touch end - deltaX: ${deltaX}, deltaY: ${deltaY}`);
                
                // Must be primarily horizontal movement
                if (absDeltaX > absDeltaY && absDeltaX > 50) {
                    if (deltaX > 0) {
                        // Swiped RIGHT - Go to Calendar
                        console.log('➡️ SWIPE RIGHT DETECTED - Going to calendar!');
                        
                        // Visual feedback
                        document.body.style.transform = 'translateX(10px)';
                        setTimeout(() => {
                            document.body.style.transform = '';
                        }, 200);
                        
                        // Navigate to calendar
                        setTimeout(() => {
                            window.location.href = 'calendar.html';
                        }, 300);
                        
                    } else {
                        // Swiped LEFT - Stay on Weather (maybe cycle weather views)
                        console.log('⬅️ SWIPE LEFT DETECTED - Staying on weather');
                        
                        // Visual feedback
                        document.body.style.transform = 'translateX(-10px)';
                        setTimeout(() => {
                            document.body.style.transform = '';
                        }, 200);
                    }
                } else {
                    console.log('🤏 Not a valid swipe gesture');
                }
                
                // Reset
                isSwipeGesture = false;
                startX = 0;
                startY = 0;
            }, { passive: false });
            
            // Alternative: Large touch zones for easier navigation
            createTouchZones();
            
            console.log('✅ RELIABLE touch navigation initialized!');
        }
        
        // Create invisible touch zones for easier navigation
        function createTouchZones() {
            // Left side - stay on weather
            const leftZone = document.createElement('div');
            leftZone.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 25%;
                height: 100vh;
                z-index: 9999;
                background: rgba(255,0,0,0.1);
                opacity: 0;
                pointer-events: auto;
            `;
            
            // Right side - go to calendar  
            const rightZone = document.createElement('div');
            rightZone.style.cssText = `
                position: fixed;
                top: 0;
                right: 0;
                width: 25%;
                height: 100vh;
                z-index: 9999;
                background: rgba(0,255,0,0.1);
                opacity: 0;
                pointer-events: auto;
            `;
            
            // Click handlers for touch zones
            leftZone.addEventListener('click', () => {
                console.log('🔄 Left zone tapped - Refresh weather');
                location.reload();
            });
            
            rightZone.addEventListener('click', () => {
                console.log('📅 Right zone tapped - Going to calendar!');
                window.location.href = 'calendar.html';
            });
            
            // Add visual feedback on touch
            [leftZone, rightZone].forEach(zone => {
                zone.addEventListener('touchstart', () => {
                    zone.style.opacity = '0.3';
                });
                zone.addEventListener('touchend', () => {
                    setTimeout(() => zone.style.opacity = '0', 200);
                });
            });
            
            document.body.appendChild(leftZone);
            document.body.appendChild(rightZone);
            
            console.log('✅ Touch zones created for easier navigation');
        }
        
        // Show cursor on touch/mouse movement
        document.addEventListener('mousemove', showCursor);
        document.addEventListener('touchstart', showCursor);
        document.addEventListener('click', showCursor);
        
        // Initialize swipe gestures
        initializeSwipeGestures();
        
        updateDateTime();
        console.log('DateTime function called');
        
        fetchWeather().then(() => {
            console.log('fetchWeather promise resolved');
        }).catch(error => {
            console.error('fetchWeather promise rejected:', error);
        });
        
        console.log('fetchWeather called, setting up intervals...');
        
        // Test if DOM elements exist
        console.log('DOM elements check:');
    // Debug logs removed for kiosk mode to avoid console spam
        
        // Initialize calendar icon functionality
        initializeCalendarIcon();
        
        // Update every 5 minutes
        setInterval(fetchWeather, 300000);  // 5 minutes
        setInterval(updateDateTime, 60000); // 1 minute
    </script>
</body>
</html>